<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<title>jetsam</title>

<script type="bitsyGameData" id="exportedGameData">
jetsam

# BITSY VERSION 4.3

! ROOM_FORMAT 1

PAL 0
NAME shore
0,36,89
72,170,170
179,217,215

PAL 1
NAME chamber
48,44,67
106,149,162
193,214,219

PAL 2
NAME hall
33,37,52
117,120,164
182,190,214

PAL 3
NAME tower
98,35,103
255,196,255
255,255,255

ROOM 0
0,25,1g,25,25,25,25,1h,25,0,2a,v,s,r,v,t
18,18,18,18,18,18,18,18,18,r,r,m,j,o,c,b
21,21,21,21,21,21,21,21,21,1e,0,0,l,x,c,m
21,21,21,21,21,21,21,21,21,1e,0,0,0,0,0,0
18,18,18,18,18,18,18,18,18,r,r,q,u,u,u,u
27,23,24,26,27,23,24,26,27,c,c,s,r,r,r,r
28,29,0,0,28,29,0,1x,l,c,m,j,c,c,c,c
2d,2e,0,1h,2d,2e,0,0,1z,22,20,j,c,22,m,1z
0,0,0,0,0,0,0,1x,1y,1y,1y,l,m,1z,20,l
0,0,0,0,0,1g,0,0,1x,1y,1z,1y,1y,1z,1y,1y
0,1h,0,0,0,0,0,0,0,2a,l,1y,1y,m,1z,m
0,0,0,0,0,0,0,0,2b,0,0,0,0,1z,m,0
0,0,0,1g,0,0,1h,0,2a,0,d,0,0,0,d,0
0,0,0,0,0,0,0,2b,0,0,0,0,0,0,0,1z
0,0,1h,0,0,0,0,2a,0,0,d,0,0,d,0,1y
0,0,0,0,0,0,0,2a,d,0,0,0,0,0,0,20
NAME shore
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
ITM 1 9,11
EXT 0,2 3 15,6
EXT 0,3 3 15,7
EXT 13,2 1 5,10
EXT 15,3 2 1,6
EXT 15,11 2 1,14
PAL 0

ROOM 1
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,2c,1r,1r,1r,1r,1r,1r,2c,0,0,0,0
0,0,0,0,1q,1y,m,0,0,l,1z,1q,0,0,0,0
0,0,0,0,1q,m,0,v,e,0,l,1q,0,0,0,0
0,0,0,0,1q,0,1z,j,1y,0,e,1q,0,0,0,0
0,0,0,0,1q,1z,1y,j,b,1z,20,1q,0,0,0,0
0,0,0,0,1q,20,z,l,m,20,1y,1q,0,0,0,0
0,0,0,0,1q,0,0,0,0,l,1y,1q,0,0,0,0
0,0,0,0,2c,1r,1r,1r,1r,1r,1r,2c,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME ruined stairs
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
ITM 6 8,10
EXT 5,10 0 13,3
PAL 1

ROOM 2
1h,0,0,0,0,1h,0,0,0,0,1g,0,0,0,1h,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,1g,0,v,20,1y,1y,2f,0,2f,y,q,1g,0,0
q,u,1z,20,m,0,0,0,l,2f,1z,0,v,0,0,1h
l,r,r,v,r,1y,15,0,1d,1y,s,r,t,15,0,0
0,0,0,0,0,0,l,2f,0,1z,l,1y,b,l,2f,0
0,0,0,0,0,0,0,2i,2f,l,1z,20,m,1d,l,15
u,0,0,u,u,u,2i,0,d,0,0,l,15,0,0,2f
r,y,r,r,r,r,q,0,2i,0,0,0,l,2f,0,1z
m,l,o,l,m,20,s,1y,2f,0,0,1d,18,18,1c,20
1z,2f,x,20,1y,1z,20,m,0,0,0,1d,21,21,1c,1y
20,2f,0,1z,m,0,d,0,0,0,1d,21,21,21,1c,2f
1z,m,0,d,0,0,v,y,21,21,21,21,21,21,1c,1z
m,d,0,2f,20,1y,q,m,18,18,18,18,18,18,1c,2f
d,0,2f,20,1y,20,q,1y,1y,20,1z,15,26,27,29,2f
0,1z,1y,2f,1z,1z,s,t,1z,0,20,t,15,28,e,20
NAME cliff
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
ITM 5 11,8
EXT 0,5 0 15,3
EXT 0,6 0 15,3
EXT 0,14 0 15,12
EXT 2,10 5 9,10
PAL 0

ROOM 3
0,0,0,0,0,1h,0,0,25,0,0,0,0,0,0,0
0,0,1g,0,0,0,0,0,0,0,0,1h,0,0,0,0
0,0,0,0,0,0,0,0,1h,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,1g,0,0
0,0,0,1h,0,0,0,0,0,0,0,0,0,0,0,0
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18
21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21
21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21
18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18
26,27,23,24,26,27,23,24,26,27,23,24,26,27,23,24
0,28,29,0,0,28,29,0,0,28,29,0,0,28,29,0
0,2d,2e,1h,0,2d,2e,0,0,2d,2e,0,0,2d,2e,1h
0,0,0,0,0,0,0,0,1g,0,0,0,0,0,0,0
0,0,1g,0,0,0,0,0,0,0,0,0,0,1g,0,0
0,0,0,0,0,1h,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,1h,0,0,0,0,0,0
NAME bridge
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
EXT 15,6 0 0,2
EXT 15,7 0 0,3
EXT 0,6 4 15,6
EXT 0,7 4 15,7
PAL 0

ROOM 4
0,1h,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,18,18,v,y,y,u,18,18,1c,1h,0,0
0,1b,18,18,2u,0,q,0,0,v,0,0,18,18,1c,0
0,1b,0,0,2u,2v,q,0,u,v,2u,0,1c,0,1c,0
1g,1b,1b,18,2u,2v,s,2o,r,t,2u,0,1c,0,1c,0
0,1b,1b,0,0,2v,l,2o,c,m,2u,0,1c,0,18,18
0,1b,1b,z,2u,0,2t,0,2t,2t,0,0,1c,1d,21,21
0,1b,1b,z,2u,0,0,0,0,0,0,0,1c,1d,21,21
0,1b,1b,z,18,18,18,18,18,18,18,18,1c,0,18,18
0,1b,1b,z,22,22,22,23,27,22,22,22,29,0,23,24
0,1b,0,0,2k,2k,2k,1e,1d,2k,2k,2k,0,0,1c,0
0,1b,0,0,0,0,0,0,0,0,0,0,0,0,1c,0
0,28,18,18,18,18,18,18,18,18,18,18,18,18,29,0
1h,1b,2j,2j,2j,2j,2j,2j,2j,2j,2j,2j,2j,2j,1c,1g
0,1b,23,27,23,27,23,27,23,27,23,27,23,27,1c,0
0,2r,2s,2r,2s,2r,2s,2r,2s,2r,2s,2r,2s,2r,2s,0
NAME pier
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,2a,2b,2k,2j,1b,1c
EXT 15,6 3 0,6
EXT 15,7 3 0,7
EXT 7,10 6 7,10
EXT 8,10 6 8,10
PAL 0

ROOM 5
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,2c,1r,1r,1r,1r,1r,1r,1r,1r,2c,0,0,0
0,0,0,1q,1s,1s,1s,1s,1s,1s,1s,1s,1q,0,0,0
0,0,0,1q,c,x,c,x,c,x,1z,20,1q,0,0,0
0,0,0,1q,c,c,c,c,m,20,1y,20,1q,0,0,0
0,0,0,1q,20,c,n,m,1y,20,20,20,1q,0,0,0
0,0,0,1q,1y,2f,0,1z,1y,20,1y,20,1q,0,0,0
0,0,0,1q,2f,0,0,0,1d,1z,m,1z,1q,0,0,0
0,0,0,1q,2i,0,0,0,d,0,0,m,1q,0,0,0
0,0,0,1q,n,1y,n,20,n,x,n,m,1q,0,0,0
0,0,0,2c,1r,1r,1r,1r,1r,1r,1r,1r,2c,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME chamber
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
ITM 0 6,9
EXT 9,11 2 2,11
PAL 1

ROOM 6
0,1h,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,v,y,y,q,0,0,0,1h,0,0
0,1b,18,18,22,22,q,0,0,v,22,22,18,18,1c,0
0,1b,0,1b,2k,2k,q,0,u,v,2k,2k,1c,0,1c,0
1g,1b,0,1s,0,0,s,v,r,t,0,0,1c,0,1c,0
0,1b,0,23,0,2v,j,c,c,b,2u,0,1c,0,18,18
0,1b,0,1b,0,2v,j,o,c,b,2u,0,1c,1d,21,21
0,1b,0,1b,0,2v,l,x,c,m,2u,0,1c,1d,21,21
0,1b,1d,z,0,0,2t,0,2t,2t,0,0,1c,0,18,18
0,1b,1b,z,0,0,0,0,0,0,0,0,1c,0,23,24
0,1b,0,0,2p,2p,2p,1e,1d,2p,2p,2p,0,0,1c,0
0,1b,0,0,0,0,0,0,0,0,0,0,0,0,1c,0
0,28,18,18,18,18,18,18,18,18,18,18,18,18,29,0
1h,1b,2j,2j,2j,2j,2j,2j,2j,2j,2j,2j,2j,2j,1c,1g
0,1b,23,27,23,27,23,27,23,27,23,27,23,27,1c,0
0,2r,2s,2r,2s,2r,2s,2r,2s,2r,2s,2r,2s,2r,2s,0
NAME hall
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,2a,2b,2k,2j,1b,1c,23,1s,z,2p
ITM 2 7,8
ITM 4 11,4
ITM 3 5,6
EXT 15,6 3 0,6
EXT 15,7 3 0,7
EXT 8,11 4 8,11
EXT 7,11 4 7,11
EXT 7,7 9 8,7
PAL 2

ROOM 7
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,1q,u,u,u,u,u,u,u,u,u,v,z,q,1q,0
0,1q,r,r,r,r,r,r,r,r,r,t,z,s,1q,0
0,1q,c,o,c,o,c,o,c,o,c,b,z,j,1q,0
0,1q,c,x,c,x,c,x,c,x,c,m,z,l,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1q,v,z,q,u,u,u,u,u,u,u,u,u,1q,0
0,1q,t,z,s,r,r,r,r,r,r,r,r,r,1q,0
0,1q,c,z,c,c,o,c,o,c,o,c,o,c,1q,0
0,1q,m,z,l,c,x,c,x,c,x,c,x,c,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1q,u,u,u,u,u,u,u,u,u,v,z,q,1q,0
0,1q,r,r,r,r,r,r,r,r,r,t,z,s,1q,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME tower1
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
ITM 7 7,6
ITM 8 9,6
ITM 8 5,6
ITM 8 3,6
ITM 8 6,11
ITM 8 8,11
ITM 8 10,11
ITM 8 12,11
EXT 12,2 7 12,13
EXT 13,6 7 2,6
EXT 2,6 7 13,6
EXT 2,11 7 13,11
EXT 13,11 7 2,11
EXT 12,13 7 12,2
EXT 7,5 8 3,6
EXT 3,5 7 8,11
EXT 5,5 b 7,6
EXT 9,5 b 6,11
EXT 6,10 7 12,11
EXT 8,10 b 10,11
EXT 10,10 7 6,11
EXT 12,10 7 8,11
PAL 3

ROOM 8
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,1q,u,u,u,u,u,u,u,u,u,v,z,q,1q,0
0,1q,r,r,r,r,r,r,r,r,r,t,z,s,1q,0
0,1q,c,o,c,o,c,o,c,o,c,b,z,j,1q,0
0,1q,c,x,c,x,c,x,c,x,c,m,z,l,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1q,v,z,q,u,u,u,u,u,u,u,u,u,1q,0
0,1q,t,z,s,r,r,r,r,r,r,r,r,r,1q,0
0,1q,c,z,c,c,o,c,o,c,o,c,o,c,1q,0
0,1q,m,z,l,c,x,c,x,c,x,c,x,c,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1q,u,u,u,u,u,u,u,u,u,v,z,q,1q,0
0,1q,r,r,r,r,r,r,r,r,r,t,z,s,1q,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME tower2
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
ITM 7 10,11
ITM 8 8,11
ITM 8 12,11
ITM 8 6,11
ITM 8 5,6
ITM 8 7,6
ITM 8 3,6
ITM 8 9,6
EXT 12,2 8 12,13
EXT 13,6 8 2,6
EXT 2,6 8 13,6
EXT 2,11 8 13,11
EXT 13,11 8 2,11
EXT 12,13 8 12,2
EXT 7,5 b 6,11
EXT 5,5 7 3,6
EXT 3,5 8 6,11
EXT 9,5 b 8,11
EXT 6,10 7 10,11
EXT 8,10 b 12,11
EXT 12,10 7 6,11
EXT 10,10 a 7,3
PAL 3

ROOM 9
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,1q,0,0,0,0,j,c,c,b,0,0,0,0,1q,0
0,1q,0,0,0,v,j,c,c,b,q,0,0,0,1q,0
0,1q,0,0,0,q,s,r,r,t,v,0,0,0,1q,0
0,1q,0,0,0,q,j,c,o,b,v,0,0,0,1q,0
0,1q,0,0,0,q,l,c,x,m,v,0,0,0,1q,0
0,1q,0,0,0,q,0,0,0,0,v,0,0,0,1q,0
0,1q,0,0,0,s,q,e,e,v,t,0,0,0,1q,0
0,1q,0,0,0,l,q,z,z,v,m,0,0,0,1q,0
0,1q,0,0,0,0,y,z,z,y,0,0,0,0,1q,0
0,1q,0,0,0,0,2r,2q,2q,2s,0,0,0,0,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME tower3
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
EXT 8,6 6 7,8
EXT 7,11 7 12,3
EXT 8,11 7 12,3
PAL 3

ROOM a
0,1h,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,v,y,y,q,0,0,0,1h,0,0
0,0,0,0,1h,0,q,0,0,v,0,0,0,0,0,0
0,0,0,0,0,0,q,0,u,v,0,0,0,0,0,0
1g,0,0,0,0,0,s,v,r,t,0,0,1g,0,0,0
0,0,0,0,0,0,j,c,c,b,0,0,0,0,0,0
0,0,0,0,0,0,j,o,c,b,0,0,0,0,0,0
0,0,0,0,0,0,j,x,c,b,0,0,0,0,0,0
0,0,0,0,1x,1y,s,r,r,t,15,0,0,0,0,0
0,1h,0,0,0,1z,1y,c,l,1y,2f,15,0,0,1h,0
0,0,0,0,1x,1y,1y,1z,1y,q,2f,2s,0,0,0,0
0,0,0,0,0,1x,20,2f,2f,2f,m,0,0,0,0,0
0,0,0,0,0,0,2r,l,m,2s,0,0,0,0,0,0
1h,0,0,0,0,0,0,0,0,0,0,0,0,1g,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,1h,0,0,0,0,0,0,0,0,0,0
NAME hall-final
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,2a,2b,2k,2j,1b,1c,23,1s,z,2p
ITM 3 6,9
ITM 5 10,10
ITM 6 7,11
ITM 4 5,7
ITM 9 8,9
ITM 1 4,11
ITM 0 9,12
END undefined 7,2
PAL 2

ROOM b
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,1q,u,u,u,u,u,u,u,u,u,v,z,q,1q,0
0,1q,r,r,r,r,r,r,r,r,r,t,z,s,1q,0
0,1q,c,o,c,o,c,o,c,o,c,b,z,j,1q,0
0,1q,c,x,c,x,c,x,c,x,c,m,z,l,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1q,v,z,q,u,u,u,u,u,u,u,u,u,1q,0
0,1q,t,z,s,r,r,r,r,r,r,r,r,r,1q,0
0,1q,c,z,c,c,o,c,o,c,o,c,o,c,1q,0
0,1q,m,z,l,c,x,c,x,c,x,c,x,c,1q,0
0,1q,0,0,0,0,0,0,0,0,0,0,0,0,1q,0
0,1q,u,u,u,u,u,u,u,u,u,v,z,q,1q,0
0,1q,r,r,r,r,r,r,r,r,r,t,z,s,1q,0
0,1u,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1r,1u,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME castle-lost
WAL b,c,j,l,m,p,q,r,s,t,u,v,y,12,15,18,1q,1r,1y,1x,1z,20,2f,1c,2a,2b,2k,2j,1b
EXT 12,2 b 12,13
EXT 13,6 b 2,6
EXT 2,6 b 13,6
EXT 2,11 b 13,11
EXT 13,11 b 2,11
EXT 12,13 b 12,2
EXT 7,5 b 10,11
EXT 5,5 b 8,11
EXT 3,5 b 7,6
EXT 9,5 b 5,6
EXT 6,10 b 10,11
EXT 8,10 b 5,6
EXT 12,10 b 7,6
EXT 10,10 b 9,6
PAL 3

TIL 12
11101111
11101111
11101111
00010001
11011011
11011011
00000101
10111111
NAME mark test

TIL 15
01110000
10101000
00001100
11100000
00110100
01001110
01101100
11110010
NAME undefined

TIL 16
10101111
10110000
00011111
11000111
11011000
11101111
01010001
10111110
NAME undefined

TIL 17
01110101
01011101
11111001
11110011
01011011
11110111
10001100
01111111
NAME undefined

TIL 18
00000000
11011111
11110110
01000100
01000100
01000100
01011101
11111111
NAME undefined

TIL 19
10011000
01100111
11010111
10111011
01011000
11100000
11000000
00100000
NAME undefined

TIL 20
00101011
01100110
01010000
11010110
00110101
01101100
00001001
11000011

TIL 21
00000000
01001011
00000000
01101101
00000000
10010110
00000000
10100101

TIL 22
11111111
10000001
00111100
01000010
10000001
10000001
11000111
00101000

TIL 23
10010100
01100010
10011001
10000111
11111110
10011000
10110000
11100000

TIL 24
01000000
00110101
11111111
11000000
00000000
00000000
00000000
00000000

TIL 25
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 26
00000010
10101100
11111111
00000011
00000000
00000000
00000000
00000000

TIL 27
00101001
01000110
10011001
11100001
01111111
00011001
00001101
00000111

TIL 28
00000110
00000011
00000011
00000001
00000001
00000001
00000001
00000001

TIL 29
01100000
11000000
11000000
10000000
10000000
10000000
10000000
10000000

TIL a
10011011
11100110
01010010
10011101
10111001
01001010
01100111
11011001
NAME undefined

TIL b
11100110
00011110
11111110
11011100
11010110
00111110
11111100
11111000
NAME undefined

TIL c
10111111
10111111
00010010
01111011
11111111
11111011
01000000
10011101
NAME undefined

TIL d
00000000
00001000
00000000
00010000
00010000
00000000
00000100
00000000
NAME undefined

TIL e
00000000
00000100
00000000
00100000
00000100
00001000
00100000
01000110
NAME undefined

TIL f
00010000
00010000
00010000
00101000
00111000
00010000
00000000
00000000
NAME undefined

TIL j
01001111
01010000
01111010
00111011
01001011
01010000
01011010
00011110
NAME undefined

TIL l
01001101
00100000
01010010
00101001
00000010
00010001
00000100
00000001
NAME undefined

TIL m
11100010
00010100
10101010
01010100
10000000
00100100
10001000
00100000
NAME undefined

TIL n
11111111
10101000
00010101
10101010
01010101
00010001
01000100
00010000
NAME undefined

TIL o
11111111
10000101
00111100
01100010
10100001
10000001
10000001
10000001
NAME undefined

TIL q
00000000
01010000
00111000
01000000
01101000
01111000
10110000
01000100
NAME undefined

TIL r
10110001
00011000
11111111
01000010
11110110
11110111
10011111
00000100
NAME undefined

TIL s
10110000
10001111
11100000
01101011
00111011
01001111
01110000
00111111
NAME undefined

TIL t
00001101
11110111
00010011
11110111
11111110
11101000
01001110
11101100
NAME undefined

TIL u
00000000
00000000
00000000
00111000
00101100
00010000
00110100
00101100
NAME undefined

TIL v
00000000
00000110
00001100
00010100
00001010
00011010
00011101
00100010
NAME undefined

TIL w
00101100
01100111
01011010
10101101
10110010
00010110
11001101
10110010
NAME undefined

TIL x
10000001
10000001
10000001
10000001
10000001
10100101
00001000
01010010
NAME undefined

TIL y
00000000
00011000
00101100
00110100
10010001
01011110
01101000
00000100
NAME undefined

TIL z
00000000
00000000
01111111
11111011
00000000
00000000
11111110
11101111
NAME undefined

TIL 1a
00011001
11100110
11101011
11011101
00011010
00000111
00000011
00000100
NAME undefined

TIL 1b
00000001
00000011
00000010
00000011
00000011
00000011
00000001
00000011
NAME undefined

TIL 1c
11000000
11000000
10000000
11000000
01000000
11000000
01000000
11000000
NAME undefined

TIL 1d
00000001
00000010
00000101
00000010
00000000
00000101
00000000
00000010
NAME undefined

TIL 1e
01000000
10100000
01000000
00000000
10100000
00000000
01000000
00000000
NAME undefined

TIL 1f
11011110
11101101
11101101
00000000
00000000
00000000
00000000
00000000
NAME undefined

TIL 1g
01100000
10010000
01100000
00000110
00001001
00000110
00110000
00000000
>
00000000
01100000
00000000
00000000
00000110
00110000
01001000
00110000
NAME undefined

TIL 1h
00000000
00000000
00000000
00000000
00100000
01010000
00100000
00000000
>
00000000
00000000
00000000
00000000
00000000
00100000
00000000
00000000
NAME undefined

TIL 1i
00000000
00010000
00010000
01101100
00010000
00010000
00000000
00000000
>
00000000
00000000
00101000
00010000
00101000
00000000
00000000
00000000
NAME undefined

TIL 1o
00000000
01001010
00101010
01000101
00010000
10001010
01000010
00010000
NAME undefined

TIL 1p
00000000
01100100
01001010
00000000
01010010
00001010
00100000
01011010
NAME undefined

TIL 1q
00000000
00011000
00001000
00001000
00010000
00010000
00011000
00000000
NAME undefined

TIL 1r
00000000
00000000
00000000
01110010
01001110
00000000
00000000
00000000
NAME undefined

TIL 1s
00000000
00000100
01000000
00010001
10000100
00100000
01101010
11010110
NAME undefined

TIL 1t
00010001
10100100
01001010
00010001
10001000
01010010
00100101
10001000
NAME undefined

TIL 1u
00101100
01100111
01011010
10101101
10110010
00010110
11001101
10110010
>
11011000
01000110
10011011
10110100
01001101
01101011
10110110
01001010
NAME undefined

TIL 1v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME undefined

TIL 1w
10000000
00000001
00000001
00000010
00100000
01000000
01000000
10000000
>
00001000
00010000
00010000
00100000
00000010
00000100
00000100
00001000
NAME undefined

TIL 1x
00000000
00000001
00010011
00101100
00011110
01000001
00111000
00000100
>
00000000
00001001
00000011
00101100
01011110
01000001
00011100
00000010

TIL 1y
00110110
01100100
01000000
00011110
00110101
01100000
00110011
11000110

TIL 1z
00001100
00011000
00000000
00001100
00110000
00100001
01100010
00000000

TIL 2a
01000000
01001100
00001100
00011000
01011000
00001000
00101000
00011000
>
00000000
10100100
00101100
00101100
10000100
00000100
01001100
00011000

TIL 2b
00000010
00001000
00000001
00000101
00000001
00011011
00000011
00000010
>
00000000
00011001
00000001
00000001
00001001
00000011
00010010
00000110

TIL 2c
01111110
11111111
11001001
10000000
01110110
00011100
01000010
00111100

TIL 2d
00000001
00000001
00000001
00000001
00000001
00000000
00000100
00000011
>
00000001
00000001
00000001
00000001
00000101
00000000
00000011
00000000

TIL 2e
10000000
10000000
10000000
10000000
10000000
00000000
00010000
11000000
>
10000000
10000000
10000000
10000000
10000000
00100000
11000000
00000000

TIL 2f
00000000
01100000
00100100
00100110
00000010
00010010
00011000
00000100

TIL 2g
00000000
11000000
01110000
10011110
01000000
00000011
00101000
00000000
>
00000000
00000000
01100000
00111110
10000111
00110000
00000101
00000000

TIL 2h
00000000
01111000
00011110
10000000
00110011
00000000
00000000
00000000
>
00000000
00000000
01111000
00001111
10000000
00101100
00000000
00000000

TIL 2i
00001000
00000000
00000000
00000100
00000100
00001000
01000000
00000000

TIL 2j
01000010
10111101
11000011
10000001
10000001
10000001
10000001
11111111

TIL 2k
10010001
10001001
10100101
10100101
10010101
10001001
10010001
11111111

TIL 2l
00001000
01000001
00000000
00001000
01000000
00000010
00000000
00100100

TIL 2m
01000000
01100000
00100000
01100000
01100000
01000000
01100000
01100000

TIL 2n
00000010
00000110
00000110
00000100
00000100
00000110
00000010
00000110

TIL 2o
00000000
01000010
01111110
00000000
00000000
01000010
01111110
00000000

TIL 2p
00000000
01111110
10000001
11111111
10010101
10001001
10010001
11111111

TIL 2q
00000000
00001010
00000000
01010000
00000000
00000000
00001100
00000000
>
00000000
00010110
00000000
01100000
00000000
00000000
00011000
00000000

TIL 2r
00000011
00010001
00000000
00001100
00000000
00000000
00000000
00000000
>
00000011
00010001
00001000
00000010
00000000
00000000
00000000
00000000

TIL 2s
11000000
10000000
00010000
01000000
00000000
00000000
00000000
00000000
>
11000000
10010000
00000000
01100000
00000000
00000000
00000000
00000000

TIL 2t
11011110
01100101
01000100
01000100
11111111
00000000
00000000
00000000

TIL 2u
10000000
10000000
10000000
00000000
10000000
10000000
10000000
10000000

TIL 2v
00000001
00000001
00000001
00000001
00000001
00000000
00000001
00000001

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
POS 4 11,2

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
>
00000000
00000000
01010100
01110010
01110010
01111100
00111100
00100100
DLG SPR_0
POS 0 8,13

SPR c
01111010
00111100
00111110
00011000
00111100
00111111
01111110
01111000
>
01111000
00111110
00111100
00011010
00111100
00111110
01111111
01111100
DLG SPR_1
POS 4 2,11

SPR d
00111100
01000010
01000010
01100110
01111110
01111010
00110100
00000000
DLG SPR_2
POS a 8,2

SPR e
00111100
01000010
01000010
01100110
01111110
01111010
00110100
00000000
POS 6 8,2

SPR f
00011000
00111100
00011000
00011110
00111001
01111000
01011000
01011000
>
00011000
00111100
00011000
00011100
00111011
01111000
01011000
01011000
DLG SPR_4
POS 2 13,12

SPR g
00001100
00001100
00100100
00011110
01101100
01111110
11011110
00101100
>
00001100
00001100
00010100
00011110
01101100
01111110
11011110
00101100
DLG SPR_9
POS 3 8,7

SPR h
00001100
10001110
11000100
11101110
11011110
01101100
00101010
00001010
>
00001100
10001110
11000100
11101110
11011110
11001100
01001010
00001010
DLG SPR_3
POS 2 1,7

SPR i
00101100
01101100
00100100
00101110
00111110
00101100
00101010
00101010
>
00101100
01101100
00100100
00101110
00111110
00101100
00101010
00101010
DLG SPR_a
POS 6 8,8

SPR j
00000110
00010110
00011010
01100111
00011111
00000110
00001010
00001010
>
00010110
00010110
00011010
01100111
00011111
00000110
00001010
00001010
DLG SPR_5
POS 0 11,2

SPR k
10011000
11011000
10101000
00011000
01111000
00011000
00101000
00100100
>
11011000
11011000
00101000
00011000
01111000
00011000
00101000
00100100
DLG SPR_6
POS 6 10,6

SPR l
11000000
11110110
00111110
00111011
10101111
10100111
10101010
10101001
>
00000110
11111110
11111011
00101111
10100111
10100111
10100101
10100101
DLG SPR_7
POS 4 4,3

SPR m
00100000
00110110
11111111
01111110
00011110
00011100
00010010
00000000
>
00100000
00110110
00111111
01111110
01111110
01011100
00010010
00000000
POS 2 11,3

SPR p
00111100
01000010
01000010
01100110
01111110
01111010
00110100
00000000
DLG SPR_b
POS 4 8,2

SPR q
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
>
00000000
00000000
01010100
01110010
01110010
01111100
00111100
00100100
DLG SPR_c
POS 9 9,7

ITM 0
00000000
00000000
00010000
00101000
00010000
00000000
00000000
00000000
NAME ring
DLG ITM_0

ITM 1
00000000
00000000
00101000
00010000
00101000
00000000
00000000
00000000
>
00000000
00010000
00010000
01101100
00010000
00010000
00000000
00000000
NAME bead
DLG ITM_1

ITM 2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME warn
DLG ITM_2

ITM 3
00000000
00011000
00100100
01010010
01000010
00100100
00011000
00000000
NAME lens
DLG ITM_3

ITM 4
00000001
00000001
00000010
00000010
00000100
00000100
01011000
00111000
DLG ITM_4

ITM 5
00000000
00000110
00011010
00111010
01110010
01100100
00001000
00000000
DLG ITM_5

ITM 6
00000000
01100000
00110000
00011000
00001100
00000010
00000000
00000000
DLG ITM_6

ITM 7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME hint-true
DLG ITM_7

ITM 8
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME hint-false
DLG ITM_8

ITM 9
00111000
01000100
00110010
00001001
01100101
11110101
11111001
01100110

DLG ITM_0
an old ring{itm1=1}

DLG ITM_1
a metallic bead{itm2=1}

DLG SPR_2
"""
{
  first = 0
}{
  - {item "bead"} > 0 ?{first = 2}
  - {item "ring"} > 0 ?{first = 1}
}{
  - placed > 0 ?you take the
}{
  - placed == 1 ? ring
  - placed == 2 ? bead
}{
  - placed > 0 ? and you place the
  - first > 0 ?you place the
  - else ?a stone altar
}{
  - first > 0 ?{placed = placed + 1}
}{
  - placed == 1 ?{- {item "ring"} == 0 ?{placed = 2}}
  - placed == 2 ?{- {item "bead"} == 0 ?{placed = 3}}
}{
  - placed == 3 ?{placed = first}
}{
  - placed == 1 ? ring
  - placed == 2 ? bead
}{
  - first > 0 ? on the altar
}
"""

DLG ITM_2
"""
{
  - warn == 0 ?
    {shk}HALT{shk}
    
    i am sworn to protect, from themselves, those who think to enter this tower. 
    those who venture without preparation do so at great peril!{warn = 1}
}
"""

DLG SPR_0
"""
{
  count = 0
  {- itm1 > 0 ?{count = count + 1}}
  {- itm2 > 0 ?{count = count + 1}}
  {- itm3 > 0 ?{count = count + 1}}
  {- itm4 > 0 ?{count = count + 1}}
  {- itm5 > 0 ?{count = count + 1}}
  {- itm6 > 0 ?{count = count + 1}}
  {- itm7 > 0 ?{count = count + 1}}
  {- count > 0 ?{state = 1}}
  count = 0
  {- itm1 > 1 ?{count = count + 1}}
  {- itm2 > 1 ?{count = count + 1}}
  {- itm3 > 1 ?{count = count + 1}}
  {- itm4 > 1 ?{count = count + 1}}
  {- itm5 > 1 ?{count = count + 1}}
  {- itm6 > 1 ?{count = count + 1}}
  {- itm7 > 1 ?{count = count + 1}}
  {- count > 0 ?{state = 2}}
  count = itm1 + itm2 + itm3 + itm4 + itm5 + itm6 + itm7 + itm8
  { - count == 14 ?{state = 3}}
}{
  - state == 3 ?
    {cycle
      - i think it's time you ended this charade
    }
  - state == 2 ?
    {cycle
      - when debris is lost in a wreck we call it flotsam,
      - when it is discarded in crisis we call it jetsam,
      - what do you think?
    }
  - state == 1 ?
    {cycle
      - these shores are all that's left, the ends of the earth,
      - a lot of lost things have washed up here,
      - funny how they have a habit of turning up, 
      - as if in desperation
    }
  - state == 0 ?
    {sequence
      - oh, you're awake
      - make yourself at home, you may be here for some time
      - come back to me if you find anything interesting
    }
}
"""

DLG SPR_3
"""
{
  - itm1 == 1 ?
    {sequence
      - that ring -- my liege!
      - your majesty, my deepest apologies, i did not recognise you
    }
  - itm1 == 2 ?
    {cycle
      - they're... they're really gone,
      - then who will lead us to the new world?
    }
  - else ?
    {cycle
      - some of us still remember the sovereigns -- long may they live!
    }
}
"""

DLG SPR_4
"""
{
  - itm2 == 1 ?
    {cycle
      - do you know the value of that bead you hold there?
      - vast halls packed with the machinery to mine and refine,
      - the material itself is of little use, but what it represents!
    }
  - itm2 == 2 ?
    {cycle
      - such waste! was it all for nothing?!
    }
  - else ?
    {cycle
      - a new fellow, welcome!
    }
}
"""

DLG SPR_5
"""
{
  - itm6 == 1 ?
    {cycle
      - you're a fiddler too? well keep up, the song must go on!
      - please... you must play along, for the good of us all
    }
  - itm6 == 2 ?
    {cycle
      - all i know is how fiddle,
      - if our song is really over... what am i to do?
    }
  - else ?
    {cycle
      - rain or shine, calm or storm, i'll play on,
      - as long as the song continues, i need not trouble myself -- we each have our parts to play
    }
}
"""

DLG SPR_6
"""
{
  - itm4 == 1 ?
    {cycle
      - yes, yes, pick up a broom and help! we'll have this place homely in a jiffy,
      - no, no, it's dirtier than when you started!
    }
  - itm4 == 2 ?
    {sequence
      - i... i can't believe it,
      - nothing but rot -- festering,
      - we could never have done enough...
    }
  - else ?
    {cycle
      - oh how the stones would gleam in the greater days,
      - standing proud, a monument to our glory,
      - its fallen into disrepair since then, but i do my bit to keep it going -- what barbaric world would this be without it?
    }
}
"""

DLG SPR_7
"""
{
  - itm3 == 1 ?
    {cycle
      - where did you get that lens? 
      - a lenses are fragile things, please be careful
    }
  - itm3 == 2 ?
    {cycle
      - the stars show us the way -- our path through time, our path through space,
      - but they are gone, and our path wends elsewhere,
      - thank you
    }
  - else ?
    {cycle
      - if i could only get the right angle
      - i just can't find the stars
    }
}
"""

DLG SPR_8
it would not be wise to enter the tower in ignorance. those who do are doomed to wander as lost souls{warn = 1}

DLG SPR_1
"""
{
  - itm7 == 1 ?
    {cycle
      - just leave me. do what must be done
    }
  - itm7 == 2 ?
    {cycle
      - my weight has been lifted, but there is still more for you to do
    }
  - else ?
    {sequence
      - i know what this is, why you are here,
      - i, of all us, should have the courage to move on,
      - but i loved my people too dearly,
      - now, take it and leave
        
        a locket{itm7=1}
    }
}
"""

DLG SPR_9
"""
{
  - itm5 == 1 ?
    {cycle
      - yes! the pier is just the beginning, 
      - from this shore we will conquer the seas!
    }
  - itm5 == 2 ?
    {cycle
      - so this is it? the seas see fit to extinguish us entirely,
      - our works abandoned and left to crumble, never to be raised again,
      - this world was ours
    }
  - else ?
    {cycle
      - isn't it beautiful? 
      - time and tide may break our works, but we build on,
      - the ruins of the past are the foundations of the future,
      - there's no revolution we can't tame
    }
}
"""

DLG SPR_b
"""
{
  first = 0
  count = itm1 + itm2 + itm3 + itm4 + itm5 + itm6 + itm7 + itm8
}{
  - itm1 == 1 ?{first = 1}{itm1 = 2}
  - itm2 == 1 ?{first = 2}{itm2 = 2}
  - itm3 == 1 ?{first = 3}{itm3 = 2}
  - itm4 == 1 ?{first = 4}{itm4 = 2}
  - itm5 == 1 ?{first = 5}{itm5 = 2}
  - itm6 == 1 ?{first = 6}{itm6 = 2}
  - itm7 == 1 ?{first = 7}{itm7 = 2}
  - itm8 == 1 ?{first = 8}{itm8 = 2}
}{
  - first > 0 ?you place the
  - else ?an ornate hammer rests across a stone altar
}{
  - first == 1 ? ring atop the altar and break it with ease. the flagbearer cries out in anguish
  - first == 2 ? bead atop the altar and smash it to a fine powder. the gentleman's fury permeates the air
  - first == 3 ? lens atop the altar and fracture it with ease. the navigator relaxes
  - first == 4 ? broom across the altar and crush it thoroughly. the custodian screams in disgust
  - first == 5 ? plumbob atop the altar and pummel it to dust. the architect sighs
  - first == 6 ? musical bow across the altar and pulverise it harshly. the fiddler's tune sours
  - first == 7 ? locket atop the altar and shatter it with a decisive blow. the lady does not react
}{
  count = count + first
  first = 0
}{
  - itm1 >= 2 ?{first = 1}
}{
  - itm2 >= 2 ?{first = 2}
}{
  - itm3 >= 2 ?{first = 3}
}{
  - itm4 >= 2 ?{first = 4}
}{
  - itm5 >= 2 ?{first = 5}
}{
  - itm6 >= 2 ?{first = 6}
}{
  - itm7 >= 2 ?{first = 7}
}{
  - itm8 >= 2 ?{first = 8}
}{ 
  - count > 0?
    
    the altar holds: 
}{ - itm1 >= 2 ?a broken ring{- first>1?, }
}{ - itm2 >= 2 ?metallic powder{- first>2?, }
}{ - itm3 >= 2 ?lens shards{- first>3?, }
}{ - itm4 >= 2 ?a splintered broom{- first>4?, }
}{ - itm5 >= 2 ?a shattered weight{- first>5?, }
}{ - itm6 >= 2 ?a snapped bow{- first>6?, }
}{ - itm7 >= 2 ?a smashed locket{- first>7?, }
"""

DLG ITM_3
a lens{itm3=1}

DLG ITM_4
a mop{itm4=1}

DLG ITM_5
a plumbob{itm5=1}

DLG ITM_6
a musical bow{itm6=1}

DLG ITM_7
"""
{count = itm1 + itm2 + itm3 + itm4 + itm5 + itm6 + itm7}{
  - count >= 14 ?
    {wvy}the voice of the navigator calls to you{wvy}
  - default ?
    {fool = fool + 1}
}
"""

DLG ITM_8
"""
{count = itm1 + itm2 + itm3 + itm4 + itm5 + itm6 + itm7}{
  - count < 14 ?
    {fool = fool + 1}
  - else ?
    {shk}the voice of the navigator shoos you away{shk}
}
"""

DLG SPR_a
"""
{count = itm1 + itm2 + itm3 + itm4 + itm5 + itm6 + itm7}{
  - fool > 0 ?
    you should not have trespassed
  - count >= 14 ?
    you are ready to enter, godspeed
  - else ?
    please leave and attend to your duties
}
"""

DLG SPR_c
"""
{count = itm1 + itm2 + itm3 + itm4 + itm5 + itm6 + itm7}{
  - count >= 14 ?
    time to go now. one mistep and you'll wonder these halls for eternity -- the way will present itself to you
  - else ?
    this is the last chance to turn back -- and with things left as they are, i daresay you should
}
"""

END 0


END undefined
the tower sits atop this last surface crag. you lift the hammer and deal one final blow

END undefinee


VAR placed
0

VAR first
0

VAR count
0

VAR warn
0

VAR itm1
0

VAR itm2
0

VAR itm3
0

VAR itm4
0

VAR itm5
0

VAR itm6
0

VAR itm7
0

VAR itm8
0

VAR fool
0

VAR state
0

VAR altar
0


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#002459;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}

canvas {
    image-rendering: pixelated;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
function Font() {


this.getData = function() {
	return fontdata;
}

var charSize = 6 * 8;
this.getChar = function(char) {
	var startIndex = char.charCodeAt(0) * charSize;
	return fontdata.slice( startIndex, startIndex + charSize );
}

var fontdata = [
		/* num: 0 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 1 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,0,1,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 2 */
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,1,0,1,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 3 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 4 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/*0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,*/
		/* num: 5 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 6 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 7 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 8 */
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,0,0,1,1,
		1,1,0,0,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 9 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 10 */
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,0,0,0,0,1,
		1,0,1,1,0,1,
		1,0,1,1,0,1,
		1,0,0,0,0,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 11 */
		0,0,0,0,0,0,
		0,0,0,1,1,1,
		0,0,0,0,1,1,
		0,0,1,1,0,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 12 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 13 */
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,1,0,1,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,1,1,1,0,0,
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 14 */
		0,0,0,0,1,1,
		0,0,1,1,0,1,
		0,0,1,0,1,1,
		0,0,1,1,0,1,
		0,0,1,0,1,1,
		0,1,1,0,1,1,
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 15 */
		0,0,0,0,0,0,
		0,1,0,1,0,1,
		0,0,1,1,1,0,
		0,1,1,0,1,1,
		0,0,1,1,1,0,
		0,1,0,1,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 16 */
		0,0,1,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,1,
		0,0,1,1,1,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 17 */
		0,0,0,0,1,0,
		0,0,0,1,1,0,
		0,0,1,1,1,0,
		0,1,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,1,0,
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 18 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 19 */
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 20 */
		0,0,1,1,1,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,1,0,1,
		0,0,0,1,0,1,
		0,0,0,1,0,1,
		0,0,0,1,0,1,
		0,0,0,0,0,0,
		/* num: 21 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,1,1,0,0,
		0,0,1,0,1,0,
		0,0,0,1,1,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 22 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 23 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		/* num: 24 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 25 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 26 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,1,1,1,1,1,
		0,0,0,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 27 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,1,1,1,1,1,
		0,0,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 28 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 29 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 30 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 31 */
		0,1,1,1,1,1,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 32 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 33 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 34 */
		0,1,1,0,1,1,
		0,1,1,0,1,1,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 35 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 36 */
		0,0,1,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,0,0,
		0,0,0,0,1,0,
		0,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 37 */
		0,1,1,0,0,1,
		0,1,1,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,1,1,
		0,1,0,0,1,1,
		0,0,0,0,0,0,
		/* num: 38 */
		0,0,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,1,0,1,
		0,1,0,0,1,0,
		0,0,1,1,0,1,
		0,0,0,0,0,0,
		/* num: 39 */
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 40 */
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 41 */
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 42 */
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,1,1,1,1,1,
		0,0,1,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 43 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 44 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		/* num: 45 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 46 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 47 */
		0,0,0,0,0,0,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 48 ZERO!!!!*/
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,1,1,
		0,1,0,1,0,1,
		0,1,1,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 49 */
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 50 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 51 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 52 */
		0,0,0,0,1,0,
		0,0,0,1,1,0,
		0,0,1,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,1,1,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 53 */
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 54 */
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 55 */
		0,1,1,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 56 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 57 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 58 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 59 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,1,0,0,0,
		/* num: 60 */
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 61 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 62 */
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 63 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 64 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,1,1,1,
		0,1,0,1,0,1,
		0,1,0,1,1,1,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 65 Start of Capital Letters*/
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 66 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 67 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 68 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 69 */
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 70 */
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 71 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 72 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 73 */
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 74 */
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 75 */
		0,1,0,0,0,1,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,1,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 76 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 77 */
		0,1,0,0,0,1,
		0,1,1,0,1,1,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 78 */
		0,1,0,0,0,1,
		0,1,1,0,0,1,
		0,1,0,1,0,1,
		0,1,0,0,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 79 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 80 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 81 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,0,0,1,0,
		0,0,1,1,0,1,
		0,0,0,0,0,0,
		/* num: 82 */
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 83 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 84 */
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 85 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 86 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 87 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 88 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 89 */
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 90 */
		0,1,1,1,1,0,
		0,0,0,0,1,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 91 */
		0,0,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 92 */
		0,0,0,0,0,0,
		0,1,0,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 93 */
		0,0,1,1,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 94 */
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 95 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		/* num: 96 */
		0,0,1,1,0,0,
		0,0,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 97 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 98 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 99 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 100 */
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 101 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 102 */
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,1,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 103 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,1,
		0,0,1,1,1,0,
		/* num: 104 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 105 */
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 106 */
		0,0,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		/* num: 107 */
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,1,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 108 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 109 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,0,1,0,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 110 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 111 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 112 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		/* num: 113 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,1,
		/* num: 114 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,1,1,0,
		0,0,1,0,0,1,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,1,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 115 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 116 */
		0,0,0,0,0,0,
		0,0,1,0,0,0,
		0,1,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 117 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 118 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 119 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,1,0,1,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 120 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 121 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,1,1,0,0,0,
		/* num: 122 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 123 */
		0,0,0,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,1,1,0,0,0,
		0,0,1,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 124 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 125 */
		0,0,1,1,0,0,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,0,0,1,1,
		0,0,0,0,1,0,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 126 */
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 127 */
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,1,0,1,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 128 */
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		/* num: 129 */
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 130 */
		0,0,0,0,1,1,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 131 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 132 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 133 */
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 134 */
		0,0,1,1,1,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 135 */
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		/* num: 136 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 137 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 138 */
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 139 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 140 */
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 141 */
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 142 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,0,1,0,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 143 */
		0,0,1,1,1,0,
		0,0,1,0,1,0,
		0,0,1,1,1,0,
		0,1,1,0,1,1,
		0,1,0,0,0,1,
		0,1,1,1,1,1,
		0,1,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 144 */
		0,0,0,0,1,1,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 145 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,1,0,1,
		0,1,1,1,1,1,
		0,1,0,1,0,0,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 146 */
		0,0,1,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,1,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,0,0,0,0,0,
		/* num: 147 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 148 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 149 */
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 150 */
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 151 */
		0,1,1,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 152 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,1,1,0,0,0,
		/* num: 153 */
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 154 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 155 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 156 */
		0,0,0,1,1,0,
		0,0,1,0,0,1,
		0,0,1,0,0,0,
		0,1,1,1,1,0,
		0,0,1,0,0,0,
		0,0,1,0,0,1,
		0,1,0,1,1,1,
		0,0,0,0,0,0,
		/* num: 157 */
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 158 */
		0,1,1,0,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,1,0,1,0,
		0,1,0,1,1,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 159 */
		0,0,0,0,1,0,
		0,0,0,1,0,1,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,0,1,0,0,
		0,0,1,0,0,0,
		/* num: 160 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 161 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		/* num: 162 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 163 */
		0,0,0,1,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 164 */
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 165 */
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,1,0,1,0,
		0,1,0,1,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		/* num: 166 */
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 167 */
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 168 */
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 169 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 170 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 171 */
		0,1,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,0,0,1,0,
		0,0,0,1,1,1,
		0,0,0,0,0,0,
		/* num: 172 */
		0,1,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,1,0,0,
		0,0,1,0,1,1,
		0,1,0,1,0,1,
		0,0,0,1,1,1,
		0,0,0,0,0,1,
		0,0,0,0,0,0,
		/* num: 173 */
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 174 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,0,1,
		0,1,0,0,1,0,
		0,0,1,0,0,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 175 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,0,1,0,0,1,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 176 */
		0,1,0,1,0,1,
		0,0,0,0,0,0,
		1,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,1,0,1,
		0,0,0,0,0,0,
		1,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 177 */
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		0,1,0,1,0,1,
		1,0,1,0,1,0,
		/* num: 178 */
		1,0,1,0,1,0,
		1,1,1,1,1,1,
		0,1,0,1,0,1,
		1,1,1,1,1,1,
		1,0,1,0,1,0,
		1,1,1,1,1,1,
		0,1,0,1,0,1,
		1,1,1,1,1,1,
		/* num: 179 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 180 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 181 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		/* num: 182 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		1,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 183 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 184 */
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 185 */
		0,1,0,1,0,0,
		1,1,0,1,0,0,
		0,0,0,1,0,0,
		1,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 186 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 187 */
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		1,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 188 */
		0,1,0,1,0,0,
		1,1,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 189 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 190 */
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 191 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 192 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 193 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 194 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 195 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 196 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 197 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 198 */
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 199 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 200 */
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,1,0,0,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 201 */
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,1,0,0,0,0,
		0,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 202 */
		0,1,0,1,0,0,
		1,1,0,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 203 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 204 */
		0,1,0,1,0,0,
		0,1,0,1,1,1,
		0,1,0,0,0,0,
		0,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 205 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 206 */
		0,1,0,1,0,0,
		1,1,0,1,1,1,
		0,0,0,0,0,0,
		1,1,0,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 207 */
		0,0,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 208 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 209 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		/* num: 210 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		/* num: 211 */
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,0,1,0,0,
		0,1,1,1,1,1,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 212 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		/* num: 213 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 214 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 215 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 216 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 217 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 218 */
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 219 */
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		1,1,1,1,1,1,
		/* num: 220 */
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		/* num: 221 */
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		/* num: 222 */
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		/* num: 223 */
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		/* num: 224 */
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		/* num: 225 */
		0,0,0,0,0,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,0,0,
		/* num: 226 */
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 227 */
		0,0,0,0,0,0,
		0,1,1,1,1,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 228 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,1,
		0,0,1,1,1,1,
		0,1,0,0,0,1,
		0,0,1,1,1,1,
		0,0,0,0,0,0,
		/* num: 229 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 230 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,0,0,
		0,1,0,0,0,0,
		0,1,0,0,0,0,
		/* num: 231 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 232 */
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 233 */
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,1,1,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 234 */
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,0,1,0,
		0,0,1,0,1,0,
		0,1,1,0,1,1,
		0,0,0,0,0,0,
		/* num: 235 */
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,0,1,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,0,1,0,
		0,0,1,1,0,0,
		0,0,0,0,0,0,
		/* num: 236 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,1,0,1,0,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 237 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,1,0,1,0,1,
		0,1,0,1,0,1,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		/* num: 238 */
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,0,
		0,1,1,1,1,0,
		0,1,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 239 */
		0,0,0,0,0,0,
		0,0,1,1,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 240 */
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 241 */
		0,0,0,0,0,0,
		0,0,0,1,0,0,
		0,0,1,1,1,0,
		0,0,0,1,0,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 242 */
		0,1,0,0,0,0,
		0,0,1,1,0,0,
		0,0,0,0,1,0,
		0,0,1,1,0,0,
		0,1,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 243 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		1,1,1,0,0,0,
		1,0,0,1,1,0,
		1,0,0,0,0,1,
		1,0,0,0,0,0,
		1,1,1,1,1,1,
		/* num: 244 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		1,1,1,1,1,1,
		0,0,0,1,1,1,
		0,1,1,0,0,1,
		1,0,0,0,0,1,
		0,0,0,0,0,1,
		1,1,1,1,1,1,
		/* num: 245 */
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,0,0,1,0,0,
		0,1,0,1,0,0,
		0,0,1,0,0,0,
		0,0,0,0,0,0,
		/* num: 246 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,0,1,1,1,0,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,1,0,0,0,1,
		0,0,1,1,1,0,
		0,0,0,0,0,0,
		/* num: 247 */
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		1,1,1,1,1,0,
		/* num: 248 */
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		1,1,1,1,0,0,
		/* num: 249 */
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		1,1,1,0,0,0,
		/* num: 250 */
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		1,1,0,0,0,0,
		/* num: 251 */
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		1,0,0,0,0,0,
		/* num: 252 */
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		0,1,0,1,1,0,
		0,0,1,0,1,0,
		0,0,0,0,0,0,
		/* num: 253 */
		0,1,1,0,0,0,
		0,0,0,1,0,0,
		0,0,1,0,0,0,
		0,1,1,1,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		/* num: 254 */
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,1,1,1,1,0,
		1,1,0,0,1,0,
		1,1,0,0,1,1,
		1,1,1,1,1,0,
		0,0,1,1,1,1,
		/* num: 255 */
		0,1,0,0,1,0,
		1,1,1,1,1,1,
		0,1,0,0,1,0,
		0,1,0,0,1,0,
		1,1,1,1,1,1,
		0,1,0,0,1,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0
];


} // Font()
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse( scriptStr );
		env.SetScript( scriptName, script );
	}
	this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
		// console.log("RUN");
		env.GetScript( scriptName )
			.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );

		// console.log("SERIALIZE!!!!");
		// console.log( env.GetScript( scriptName ).Serialize() );
	}
	this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var script = parser.Parse( scriptStr );
		script.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	// TODO : move to utils?
	// for reading in dialog from the larger file format
	this.ReadDialogScript = function(lines, i) {
		return parser.ReadDialogScript(lines,i);
	}

	this.Parse = function(scriptStr) { // parses a script but doesn't save it
		return parser.Parse( scriptStr );
	}
	this.Eval = function(scripTree, exitHandler) { // runs a script stored externally
		scripTree.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression( expStr );
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if(doIndentFirstLine === undefined) doIndentFirstLine = true;
		var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
		for(var i = 0; i < children.length; i++) {
			block.AddChild( children[i] );
		}
		return block;
	}

	this.ChangeSequenceType = function(oldSequence,type) {
		if(type === "sequence") {
			return new SequenceNode( oldSequence.options );
		}
		else if(type === "cycle") {
			return new CycleNode( oldSequence.options );
		}
		else if(type === "shuffle") {
			return new ShuffleNode( oldSequence.options );
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new BlockNode( BlockMode.Code );
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new BlockNode( BlockMode.Dialog );
		var result2 = new BlockNode( BlockMode.Dialog );

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( ifNode );
		return block;
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function sayFunc(environment,parameters,onReturn) {
	// console.log("SAY FUNC");
	// console.log(parameters);
	if( parameters[0] != undefined && parameters[0] != null ) {
		// console.log(parameters[0]);
		// console.log(parameters[0].toString());
		// var textStr = parameters[0].toString();
		var textStr = "" + parameters[0];
		// console.log(textStr);
		var onFinishHandler = function() {
			// console.log("FINISHED PRINTING ---- SCRIPT");
			onReturn(null);
		}; // called when dialog is finished printing
		environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
	}
	else
		onReturn(null);
}

function linebreakFunc(environment,parameters,onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	onReturn(null);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
	// console.log("ITEM FUNC " + itemId + " " + itemCount);
	onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("say", sayFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn) {
		// console.log(functionMap);
		// console.log(name);
		functionMap.get( name )( this, parameters, onReturn );
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler)
			onVariableChangeHandler(name);
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler)
				onVariableChangeHandler(name);
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.children.length; i++ ) {
			this.children[i].VisitAll( visitor );
		}
	};
}

var BlockMode = {
	Code : "code",
	Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "block";
	this.mode = mode;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if( this.onEnter != null ) this.onEnter();

		var lastVal = null;
		var i = 0;
		function evalChildren(children,done) {
			if(i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval( environment, function(val) {
					// console.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this;
		evalChildren( this.children, function() {
			if( self.onExit != null ) self.onExit();
			onReturn(lastVal);
		} );
	}

	if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

	this.Serialize = function(depth) {
		if(depth === undefined) depth = 0;

		console.log("SERIALIZE BLOCK!!!");
		console.log(depth);
		console.log(doIndentFirstLine);

		var str = "";
		var lastNode = null;
		if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
				str += "\n";

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
				str += leadingWhitespace(depth);
			str += curNode.Serialize(depth);
			lastNode = curNode;
		}
		if (this.mode === BlockMode.Code) str += "}";
		return str;
	}
}

function isBlockWithNoNewline(node) {
	return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
				return true;
			}
		}
	}
	return false;
}

function isMultilineListBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0) {
			var child = node.children[0];
			if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
				return true;
			}
		}
	}
	return false;
}

var FuncNode = function(name,arguments) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.arguments = arguments;

	this.Eval = function(environment,onReturn) {

		if( this.onEnter != null ) this.onEnter();

		// console.log("FUNC");
		// console.log(this.arguments);
		var argumentValues = [];
		var i = 0;
		function evalArgs(arguments,done) {
			if(i < arguments.length) {
				// Evaluate each argument
				arguments[i].Eval( environment, function(val) {
					argumentValues.push( val );
					i++;
					evalArgs(arguments,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this; // hack to deal with scope
		evalArgs( this.arguments, function() {
			// Then evaluate the function
			// console.log("ARGS");
			// console.log(argumentValues);

			if( self.onExit != null ) self.onExit();

			environment.EvalFunction( self.name, argumentValues, onReturn );
		} );
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
		if(isDialogBlock && this.name === "say") {
			// TODO this could cause problems with "real" say functions
			return this.arguments[0].value; // first argument should be the text of the {say} func
		}
		else if(isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.arguments.length; i++) {
				str += " ";
				str += this.arguments[i].Serialize(depth);
			}
			return str;
		}
	}
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if(this.value === null)
			return str;

		if(typeof this.value === "string") str += '"';
		str += this.value;
		if(typeof this.value === "string") str += '"';

		return str;
	}
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if(!isNegativeNumber) {
			var str = "";
			str += this.left.Serialize(depth);
			str += " " + this.operator + " ";
			str += this.right.Serialize(depth);
			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		if(this.left != null)
			this.left.VisitAll( visitor );
		if(this.right != null)
			this.right.VisitAll( visitor );
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.options.length; i++) {
			// console.log("SERIALIZE SEQUENCE ");
			// console.log(depth);
			str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.options.length; i++ ) {
			this.options[i].VisitAll( visitor );
		}
	};
}

var SequenceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "sequence";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("SEQUENCE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
	}
}

var CycleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "cycle";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("CYCLE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
		else
			index = 0;
	}
}

var ShuffleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "shuffle";
	this.options = options;

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while(optionsUnshuffled.length > 0) {
			var i = Math.floor( Math.random() * optionsUnshuffled.length );
			optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
		}
	}
	shuffle(this.options);

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// OLD RANDOM VERSION
		// var index = Math.floor(Math.random() * this.options.length);
		// this.options[index].Eval( environment, onReturn );

		optionsShuffled[index].Eval( environment, onReturn );
		
		index++;
		if (index >= this.options.length) {
			shuffle(this.options);
			index = 0;
		}
	}
}

var IfNode = function(conditions, results, isSingleLine) {
	Object.assign( this, new TreeRelationship() );
	this.type = "if";
	this.conditions = conditions;
	this.results = results;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		var self = this;
		function TestCondition() {
			// console.log("EVAL " + i);
			self.conditions[i].Eval(environment, function(val) {
				// console.log(val);
				if(val == true) {
					self.results[i].Eval(environment, onReturn);
				}
				else if(i+1 < self.conditions.length) {
					i++;
					TestCondition(); // test next condition
				}
				else {
					onReturn(null); // out of conditions and none were true
				}
			});
		};
		TestCondition();
	}

	if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
			if(this.conditions.length > 1 && this.conditions[1].type === "else")
				str += " : " + this.results[1].Serialize();
		}
		else {
			str += "\n";
			for (var i = 0; i < this.conditions.length; i++) {
				str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
				str += this.results[i].Serialize(depth + 2) + "\n";
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.conditions.length; i++ ) {
			this.conditions[i].VisitAll( visitor );
		}
		for( var i = 0; i < this.results.length; i++ ) {
			this.results[i].VisitAll( visitor );
		}
	};
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "else";

	this.Eval = function(environment,onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return "else";
	}
}

var Sym = {
	// DialogOpen : "/\"",
	// DialogClose : "\"/",
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"'
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr) {
		// console.log("NEW PARSE!!!!!!");

		// TODO : make this work for single-line, no dialog block scripts

		var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
			state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
			state = ParseDialog( state );
		}
		// else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
		// 	// code-block: should this ever happen?
		// 	state = ParseCodeBlock( state );
		// }
		else {
			// single-line dialog block
			state = ParseDialog( state );
		}

		// console.log( state.rootNode );
		return state.rootNode;
	};

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
		}
		return { script:scriptStr, index:i };
	}

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}
		this.Print = function() {console.log(sourceStr);};
	};

	function ParseDialog(state) {
		// console.log("PARSE DIALOG");
		state.Print();

		// for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
		var hasBlock = false;
		var hasDialog = false;
		var isFirstLine = true;

		// console.log("---- PARSE DIALOG ----");

		var text = "";
		var addTextNode = function() {
			// console.log("TEXT " + text.length);
			if (text.length > 0) {
				// console.log("TEXT " + text);
				// console.log("text!!");
				// console.log([text]);

				state.curNode.AddChild( new FuncNode( "say", [new LiteralNode(text)] ) );
				text = "";

				hasDialog = true;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );

				// console.log("CODE");

				var len = state.curNode.children.length;
				if(len > 0 && state.curNode.children[len-1].type === "block") {
					var block = state.curNode.children[len-1];
					if(isMultilineListBlock(block))
						hasDialog = true; // hack to get correct newline behavior for multiline blocks
				}

				hasBlock = true;
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	addTextNode();
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)

			// 	hasBlock = true;
			// }
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					/*
					NOTES:
					linebreaks SHOULD happen on
					- lines with text (including the first or last line)
					- empty lines (that are NOT the first or last line)
					linebreaks should NOT happen on
					- lines with only CODE blocks
					- empty FIRST or LAST lines

					also, apparently:
					- NEVER line break on the last line
					*/
					var isLastLine = (state.Index() + 1) == state.Count();
					// console.log("block " + hasBlock);
					// console.log("dialog " + hasDialog);
					var isEmptyLine = !hasBlock && !hasDialog;
					// console.log("empty " + isEmptyLine);
					var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
					// console.log("valid empty " + isValidEmptyLine);
					var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
					// console.log("LINEBREAK? " + shouldAddLinebreak);
					if( shouldAddLinebreak ) {
						// console.log("NEWLINE");
						// console.log("empty? " + isEmptyLine);
						// console.log("dialog? " + hasDialog);
						state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
					}

					// linebreak logic
					isFirstLine = false;
					hasBlock = false;
					hasDialog = false;

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		// console.log("---- PARSE DIALOG ----");

		// console.log(state);
		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	function ParseIf(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var isNewline = true;
		var isConditionDone = false;
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				curIndex++;
				isConditionDone = false;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}
			else if(curIndex > -1) {
				if(!isConditionDone) {
					if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
						// end of condition
						isConditionDone = true;
					}
					else {
						// read in condition
						conditionStrings[curIndex] += state.Char();
					}
				}
				else {
					// read in result
					if(!isSkippableWhitespace)
						resultStrings[curIndex] += state.Char();
				}
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			state.Step();
		}

		// console.log("PARSE IF:");
		// console.log(conditionStrings);
		// console.log(resultStrings);

		var conditions = [];
		for(var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if(str === "else") {
				conditions.push( new ElseNode() );
			}
			else {
				var exp = CreateExpression( str );
				conditions.push( exp );
			}
		}

		var results = [];
		for(var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			results.push( dialogBlock );
		}

		state.curNode.AddChild( new IfNode( conditions, results ) );

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	// TODO: don't forget about eating whitespace
	function ParseSequence(state, sequenceType) {
		// console.log("SEQUENCE " + sequenceType);
		state.Print();

		var isNewline = false;
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				// console.log("found next list item");
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}
			else if(curItemIndex > -1) {
				if(!isSkippableWhitespace)
					itemStrings[curItemIndex] += state.Char();
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			// console.log(state.Char());
			state.Step();
		}
		// console.log(itemStrings);
		// console.log("SEQUENCE DONE");

		var options = [];
		for(var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			options.push( dialogBlock );
		}

		// console.log(options);

		if(sequenceType === "sequence")
			state.curNode.AddChild( new SequenceNode( options ) );
		else if(sequenceType === "cycle")
			state.curNode.AddChild( new CycleNode( options ) );
		else if(sequenceType === "shuffle")
			state.curNode.AddChild( new ShuffleNode( options ) );

		return state;
	}

	function ParseFunction(state, funcName) {
		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	var setSymbol = "=";
	var ifSymbol = "?";
	var elseSymbol = ":";
	// var operatorSymbols = ["==", ">", "<", ">=", "<=", "*", "/", "+", "-"];
	var operatorSymbols = ["-", "+", "/", "*", "<=", ">=", "<", ">", "=="]; // operators need to be in reverse order
	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}
	
		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(setSymbol);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = setSymbol;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(ifSymbol);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = ifSymbol;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+ifSymbol.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
			var opSym = operatorSymbols[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function ParseExpression(state) {
		var line = state.Peak( [Sym.Linebreak] );
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression( line );
		// console.log(exp);
		state.curNode.AddChild( exp );
		state.Step( line.length );
		return state;
	}

	function ParseCode(state) {
		// TODO : how do I do this parsing??? one expression per block? or per line?
		while ( !state.Done() ) {

			if( state.Char() === " " || state.Char() === "\t" || state.Char() === "\n" ) { // TODO: symbols? IsWhitespace func?
				state.Step(); // consume whitespace
			}
			else if( state.MatchAhead(Sym.CodeOpen) ) {
				state = ParseCodeBlock( state );
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)
			// }
			else if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
				// console.log("PEAK IF " + state.Peak( ["?"] ));
				state = ParseIf( state );
			}
			else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
				var funcName = state.Peak( [" "] );
				state.Step( funcName.length );
				state = ParseFunction( state, funcName );
			}
			else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
				var sequenceType = state.Peak( [" ", Sym.Linebreak] );
				state.Step( sequenceType.length );
				state = ParseSequence( state, sequenceType );
			}
			else {
				state = ParseExpression( state );
			}
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

		// console.log("PARSE CODE");
		// console.log(codeStr);

		var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
		codeState = ParseCode( codeState );
		
		state.curNode.AddChild( codeState.rootNode );

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
	};
	
	var font = new Font();

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col) {
		char.offset = {x:0, y:0};
		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);
		var charData = font.getChar( char.char );
		var top = (4 * scale) + (row * 2 * scale) + (row * 8 * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (col * 6 * text_scale) + Math.floor( char.offset.x );
		for (var y = 0; y < 8; y++) {
			for (var x = 0; x < 6; x++) {
				var i = (y * 6) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}

					
				}
			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) { // TODO move out of the buffer?? (into say a dialog box renderer)
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	
	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);
			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char)
					handler( char, i /*rowIndex*/, j /*colIndex*/ );
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		activeTextEffects = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		// console.log("DO NEXT CHAR");

		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;

			// console.log("WAITING FOR INPUT");
		}

		// console.log(this.CurChar());
		if(this.CurChar() != null)
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		console.log("END!!!!");
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog
	}

	this.Continue = function() {
		console.log("CONTINUE");
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(char,effectList) {
		this.char = char;
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)
		this.row = 0;
		this.col = 0;
		this.SetPosition = function(row,col) {
			this.row = row;
			this.col = col;
		};

		this.ApplyEffects = function(time) {
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}
	};

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogChar( word[i], effectList ) );
		}
		return charArray;
	}

	var charsPerRow = 32;
	this.AddText = function(textStr,onFinishHandler) {
		console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			var wordLength = word.length + ((i == 0) ? 0 : 1);
			if (curRowArr.length + wordLength <= charsPerRow || curRowArr.length <= 0) {
				//stay on same row
				var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );

		//finish up 
		lastPage = buffer[ buffer.length-1 ];
		lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length > 0 ) {
			var lastChar = lastRow[ lastRow.length-1 ];
			lastChar.SetPrintHandler( onFinishHandler );
		}

		console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[ buffer.length-1 ];
		if( lastPage.length <= 1 ) {
			console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push( [] );
		}
		else {
			// add new page
			buffer.push( [[]] );
		}
		console.log(buffer);

		isActive = true;
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };
};

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

} // Dialog()
</script>

<script>
var xhr;
var canvas;
var context;
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = {
	"0" : [[0,0,0],[255,0,0],[255,255,255]] //start off with a default palette (can be overriden)
};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/ // TODO
	/*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
	names.room = new Map();
	for(id in room) {
		if(room[id].name != undefined && room[id].name != null)
			names.room.set( room[id].name, id );
	}
	names.tile = new Map();
	for(id in tile) {
		if(tile[id].name != undefined && tile[id].name != null)
			names.tile.set( tile[id].name, id );
	}
	names.sprite = new Map();
	for(id in sprite) {
		if(sprite[id].name != undefined && sprite[id].name != null)
			names.sprite.set( sprite[id].name, id );
	}
	names.item = new Map();
	for(id in item) {
		if(item[id].name != undefined && item[id].name != null)
			names.item.set( item[id].name, id );
	}
}

//stores all image data for tiles, sprites, drawings
var imageStore = {
	source: {},
	render: {}
};

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 4, // for file format / engine changes
	minor: 3 // for editor changes and bugfixes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette (can be overriden)
		"0" : {
			name : null,
			colors : [[0,0,0],[255,0,0],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	//stores all image data for tiles, sprites, drawings
	imageStore = {
		source: {},
		render: {}
	};

	spriteStartLocations = {};

	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map()
	};
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;

var isPlayerEmbeddedInEditor = false;

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
    var audio = document.getElementById("music");
    audio.volume = 0.8;

	curGameData = game_data; //remember the current game (used to reset the game)
	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?
	// console.log(dialog);
	parseWorld(game_data);
	// console.log(dialog);
	setInitialVariables();
	renderImages();
	onready(startWithTitle);
	// console.log(dialog);
}

function reset_cur_game() {
	if (curGameData == null) return; //can't reset if we don't have the game data
	stopGame();
	clearGameData();
	load_game(curGameData);
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	document.addEventListener('keydown', onkeydown);
	document.addEventListener('keyup', onkeyup);

	canvas.addEventListener('touchstart', ontouchstart);
	canvas.addEventListener('touchmove', ontouchmove);
	canvas.addEventListener('touchend', ontouchend);

	update_interval = setInterval(function(){}, -1);
    var u = function(){
        if(update_interval){
            update();
            requestAnimationFrame(u);
        }
    };
    u();

	console.log("TITLE ??? " + startWithTitle);
	if(startWithTitle) // used by editor
		startNarrating(title);
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// OLD VERSION: DEPRECATED
// function onTouch(e) {
// 	console.log("MOUSEDOWN");

// 	//dialog mode
// 	// if (isDialogMode) {
// 	if(dialogBuffer.IsActive()) {

// 		if (dialogBuffer.CanContinue()) {
// 			var hasMoreDialog = dialogBuffer.Continue();
// 			if(!hasMoreDialog) {
// 				onExitDialog();
// 			}
// 		}
// 		else {
// 			dialogBuffer.Skip();
// 		}

// 		return;
// 	}

// 	if (isEnding) {
// 		reset_cur_game();
// 		return;
// 	}

// 	//walking mode
// 	var off = getOffset(e);
// 	var x = Math.floor(off.x / (tilesize*scale));
// 	var y = Math.floor(off.y / (tilesize*scale));
	
// 	//abort if you touch the square you're already on
// 	if (player().x == x && player().y == y) {
// 		return;
// 	}

// 	//did we touch a sprite?
// 	var touchedSprite = null;
// 	for (id in sprite) {
// 		var spr = sprite[id];
// 		if (spr.room === curRoom) {
// 			if (spr.x == x && spr.y == y) {
// 				touchedSprite = id;
// 			}
// 		}
// 	}

// 	//respond to sprite touch
// 	if (touchedSprite) {
// 		var spr = sprite[touchedSprite];
// 		// console.log(Math.abs(player().x - spr.x));
// 		// console.log(Math.abs(player().y - spr.y));
// 		if ( Math.abs(player().x - spr.x) == 0
// 				&& Math.abs(player().y - spr.y) == 1 )
// 		{
// 			//touched a sprite next to you
// 		}
// 		else if ( Math.abs(player().y - spr.y) == 0
// 				&& Math.abs(player().x - spr.x) == 1 )
// 		{
// 			//touched a sprite next to you
// 		}
// 		else
// 		{
// 			return; //oh no! touched a sprite that's out of range
// 		}

// 		startSpriteDialog( touchedSprite /*spriteId*/ );

// 		return;
// 	}

// 	//did we touch an open square?
// 	var row = room[curRoom].tilemap[y];
// 	// console.log(row);
// 	var til = row[x];
// 	// console.log(til);
// 	if ( room[curRoom].walls.indexOf(til) != -1 ) {
// 		//touched a wall
// 		return;
// 	}

// 	//find path to open square, if there is one
// 	var map = collisionMap(curRoom);
// 	var path = breadthFirstSearch( map, {x:player().x, y:player().y}, {x:x,y:y} );
// 	path = path.slice(1); //remove player's start square

// 	//console.log( pathToString(path) );

// 	player().walkingPath = path;
// }

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', onkeydown);
	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	//clear screen
	ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
	ctx.fillRect(0,0,canvas.width,canvas.height);
	
	if (!isNarrating && !isEnding) {
		updateAnimation();
		drawRoom( room[curRoom] ); // draw world if game has begun
	}

	// if (isDialogMode) { // dialog mode
	if(dialogBuffer.IsActive()) {
		dialogRenderer.Draw( dialogBuffer, deltaTime );
		dialogBuffer.Update( deltaTime );
	}
	else if (!isEnding) {
		moveSprites();

		if (player().walkingPath.length > 0) {
			var dest = player().walkingPath[ player().walkingPath.length - 1 ];
			ctx.fillStyle = "#fff";
			ctx.globalAlpha = 0.5;
			ctx.fillRect( dest.x * tilesize*scale, dest.y * tilesize*scale, tilesize*scale, tilesize*scale );
			ctx.globalAlpha = 1;
		}
	}

	// keep moving avatar if player holds down button
	if( !dialogBuffer.IsActive() && !isEnding )
	{
		if( curPlayerDirection != Direction.None ) {
			playerHoldToMoveTimer -= deltaTime;

			if( playerHoldToMoveTimer <= 0 )
			{
				movePlayer( curPlayerDirection );
				playerHoldToMoveTimer = 150;
			}
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) onPlayerMoved();
	didPlayerMoveThisFrame = false;
	// if (didDialogUpdateThisFrame && onDialogUpdate != null) onDialogUpdate();
	// didDialogUpdateThisFrame = false;
	/* hacky replacement */
	if (onDialogUpdate != null)
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] )
						spr.inventory[ itm.id ] += 1;
					else
						spr.inventory[ itm.id ] = 1;

					if(onInventoryChanged != null)
						onInventoryChanged( itm.id );

					if(id === playerId)
						startItemDialog( itm.id  /*itemId*/ );

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var keyDownList = [];

function onkeydown(e) {
	if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
		e.preventDefault();

	if( keyDownList.indexOf( e.keyCode ) != -1 ) {
		// key already down --- do nothing
		return;
	}

	curPlayerDirection = Direction.None;

	if( dialogBuffer.IsActive() ) {
		/* CONTINUE DIALOG */
		if (dialogBuffer.CanContinue()) {
			var hasMoreDialog = dialogBuffer.Continue();
			if(!hasMoreDialog) {
				console.log("EXIT DIALOG --- onkeydown")
				onExitDialog();
			}
		}
		else {
			dialogBuffer.Skip();
		}
	}
	else if ( isEnding ) {
		/* RESTART GAME */
		reset_cur_game();
	}
	else {
		/* WALK */
		if ( e.keyCode == key.left || e.keyCode == key.a ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( e.keyCode == key.right || e.keyCode == key.d ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( e.keyCode == key.up || e.keyCode == key.w ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( e.keyCode == key.down || e.keyCode == key.s ) {
			curPlayerDirection = Direction.Down;
		}
		movePlayer( curPlayerDirection );

		if( curPlayerDirection != Direction.None )
		{
			playerHoldToMoveTimer = 500;
		}

		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	if( keyDownList.indexOf( e.keyCode ) == -1 )
		keyDownList.push( e.keyCode );

	console.log("KEY DOWN " + keyDownList.length );
	console.log(keyDownList);
}

function movePlayer(direction) {
	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
		didPlayerMoveThisFrame = true;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );
	if (end) {
		startNarrating( ending[end.id], true /*isEnding*/ );
	}
	else if (ext) {
		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	}
	else if (spr) {
		startSpriteDialog( spr /*spriteId*/ );
	}
	else if (itmIndex > -1) {
		// TODO pick up items (what about touch?)
		// console.log("HIT ITM ");
		// console.log( itmIndex );
		var itm = room[ player().room ].items[ itmIndex ];
		// console.log(itm);
		room[ player().room ].items.splice( itmIndex, 1 );
		if( player().inventory[ itm.id ] )
			player().inventory[ itm.id ] += 1;
		else
			player().inventory[ itm.id ] = 1;

		if(onInventoryChanged != null)
			onInventoryChanged( itm.id );

		startItemDialog( itm.id  /*itemId*/ );

		// console.log( player().inventory );
	}
}

function onkeyup(e) {

	if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
		e.preventDefault();

	if( keyDownList.indexOf( e.keyCode ) != -1 )
		keyDownList.splice( keyDownList.indexOf( e.keyCode ), 1 );

	// todo is this robust enough?
	if( keyDownList.length <= 0 )
		curPlayerDirection = Direction.None;

	console.log(e.keyCode);
	console.log("KEY UP " + keyDownList.length );
	console.log(keyDownList);
	console.log("_____");
}

var touchInfo = {
	isDown : false,
	startX : 0,
	startY : 0,
	curX : 0,
	curY : 0
};

function ontouchstart(e) {
	e.preventDefault();

	if( e.changedTouches.length > 0 ) {
		touchInfo.isDown = true;

		console.log(e);

		touchInfo.startX = touchInfo.curX = e.changedTouches[0].clientX;
		touchInfo.startY = touchInfo.curY = e.changedTouches[0].clientY;

		console.log("MOUSE DOWN");
		console.log(touchInfo);

		curPlayerDirection = Direction.None;
	}
}

var swipeDistance = 30;
function ontouchmove(e) {
	e.preventDefault();

	console.log("MOUSE MOVE");
	console.log(touchInfo);

	if( !dialogBuffer.IsActive() && touchInfo.isDown && e.changedTouches.length > 0 ) {
		touchInfo.curX = e.changedTouches[0].clientX;
		touchInfo.curY = e.changedTouches[0].clientY;

		var prevDirection = curPlayerDirection;

		console.log( touchInfo.curX - touchInfo.startX );

		if( touchInfo.curX - touchInfo.startX <= -swipeDistance ) {
			curPlayerDirection = Direction.Left;
		}
		else if( touchInfo.curX - touchInfo.startX >= swipeDistance ) {
			curPlayerDirection = Direction.Right;
		}
		else if( touchInfo.curY - touchInfo.startY <= -swipeDistance ) {
			curPlayerDirection = Direction.Up;
		}
		else if( touchInfo.curY - touchInfo.startY >= swipeDistance ) {
			curPlayerDirection = Direction.Down;
		}

		if( curPlayerDirection != prevDirection ) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 300;
			// reset center
			touchInfo.startX = touchInfo.curX;
			touchInfo.startY = touchInfo.curY;
		}
	}
}

function ontouchend(e) {
	e.preventDefault();

	console.log("MOUSE UP");
	console.log(touchInfo);

	touchInfo.isDown = false;

	if( curPlayerDirection == Direction.None ) {
		// tap!
		if( dialogBuffer.IsActive() ) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					console.log("EXIT DIALOG --- onkeydown")
					onExitDialog();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
		else if ( isEnding ) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}

	curPlayerDirection = Direction.None;
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return isWall( player().x - 1, player().y ) || (player().x - 1 < 0);
}

function isWallRight() {
	return isWall( player().x + 1, player().y ) || (player().x + 1 >= 16);
}

function isWallUp() {
	return isWall( player().x, player().y - 1 ) || (player().y - 1 < 0);
}

function isWallDown() {
	return isWall( player().x, player().y + 1 ) || (player().y + 1 >= 16);
}

function isWall(x,y) {
	// console.log(x + " " + y);
	var i = getRoom().walls.indexOf( getTile(x,y) );
	return i > -1;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	resetFlags();

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}
	placeSprites();
	if (player().room != null) {
		curRoom = player().room;
	}

	console.log(names);
}

//TODO this is in progress and doesn't support all features
function serializeWorld() {
	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* PALETTE */
	for (id in palette) {
		worldStr += "PAL " + id + "\n";
		if( palette[id].name != null )
			worldStr += "NAME " + palette[id].name + "\n";
		for (i in getPal(id)) {
			for (j in getPal(id)[i]) {
				worldStr += getPal(id)[i][j];
				if (j < 2) worldStr += ",";
			}
			worldStr += "\n";
		}
		worldStr += "\n";
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null) {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	return worldStr;
}

function serializeDrawing(drwId) {
	var drwStr = "";
	for (f in imageStore.source[drwId]) {
		for (y in imageStore.source[drwId][f]) {
			var rowStr = "";
			for (x in imageStore.source[drwId][f][y]) {
				rowStr += imageStore.source[drwId][f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageStore.source[drwId].length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				}
			};
			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set( name, id);
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; //default palette color index is 1
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}	
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		i++;
	}

	//tile data
	tile[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (imageStore.source[drwId].length > 1),
			frameIndex : 0,
			frameCount : imageStore.source[drwId].length
		},
		name : name
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (imageStore.source[drwId].length > 1),
			frameIndex : 0,
			frameCount : imageStore.source[drwId].length
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (imageStore.source[drwId].length > 1),
			frameIndex : 0,
			frameCount : imageStore.source[drwId].length
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	imageStore.source[drwId] = []; //init list of frames
	imageStore.source[drwId].push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		imageStore.source[drwId][frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				imageStore.source[drwId].push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	//console.log(imageStore.source[drwId]);
	return i;
}

function renderImages() {
	console.log(" -- RENDER IMAGES -- ");

	//init image store
	for (pal in palette) {
		imageStore.render[pal] = {
			"1" : {}, //images with primary color index 1 (usually tiles)
			"2" : {}  //images with primary color index 2 (usually sprites)
		};
	}

	//render images required by sprites
	for (s in sprite) {
		var spr = sprite[s];
		renderImageForAllPalettes( spr );
	}
	//render images required by tiles
	for (t in tile) {
		var til = tile[t];
		renderImageForAllPalettes( til );
	}
	//render images required by tiles
	for (i in item) {
		var itm = item[i];
		renderImageForAllPalettes( itm );
	}
}

function renderImageForAllPalettes(drawing) {
	console.log("RENDER IMAGE");
	for (pal in palette) {
		console.log(pal);
		var col = drawing.col;
		var colStr = "" + col;
		console.log(drawing);
		console.log(drawing.drw);
		console.log(imageStore);
		var imgSrc = imageStore.source[ drawing.drw ];
		if ( imgSrc.length <= 1 ) {
			// non-animated drawing
			var frameSrc = imgSrc[0];
			console.log(drawing);
			console.log(imageStore);
			imageStore.render[pal][colStr][drawing.drw] = imageDataFromImageSource( frameSrc, pal, col );
		}
		else {
			// animated drawing
			var frameCount = 0;
			for (f in imgSrc) {
				var frameSrc = imgSrc[f];
				var frameId = drawing.drw + "_" + frameCount;
				imageStore.render[pal][colStr][frameId] = imageDataFromImageSource( frameSrc, pal, col );
				frameCount++;
			}
		}		
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = ctx.createImageData(tilesize*scale,tilesize*scale);
	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if (px === 1) {
						img.data[pxl + 0] = getPal(pal)[col][0]; //ugly
						img.data[pxl + 1] = getPal(pal)[col][1];
						img.data[pxl + 2] = getPal(pal)[col][2];
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = getPal(pal)[0][0];
						img.data[pxl + 1] = getPal(pal)[0][1];
						img.data[pxl + 2] = getPal(pal)[0][2];
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}
	return img;
}

function parseDialog(lines, i) {
	var id = getId(lines[i]);
	i++;

	// TODO : use this for titles & endings too
	var results = scriptInterpreter.ReadDialogScript(lines,i);
	dialog[id] = results.script;
	i = results.index;

	return i;
}

function parseEnding(lines, i) {
	var id = getId(lines[i]);
	i++;
	var text = lines[i];
	i++;
	ending[id] = text;
	return i;
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	context.putImageData(img,x*tilesize*scale,y*tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

function drawRoom(room,context) {
	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],getRoomPal(room.id)), j, i, context );
				}
			}
		}
	}
	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],getRoomPal(room.id)), itm.x, itm.y, context );
	}
	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,getRoomPal(room.id)), spr.x, spr.y, context );
		}
	}
}

function getTileImage(t,palId,frameIndex) {
	if( frameIndex === undefined ) frameIndex = null; // no default parameter support on iOS

	var drwId = t.drw;

	if (!palId) palId = curPal();

	if ( t.animation.isAnimated ) {
		if (frameIndex != null) { // use optional provided frame index
			// console.log("GET TILE " + frameIndex);
			drwId += "_" + frameIndex;
		}
		else { // or the one bundled with the tile
			drwId += "_" + t.animation.frameIndex;
		}
	}
	return imageStore.render[ palId ][ t.col ][ drwId ];
}

function getSpriteImage(s,palId,frameIndex) {
	if( frameIndex === undefined ) frameIndex = null; // no default parameter support on iOS

	var drwId = s.drw;

	if (!palId) palId = curPal();

	if ( s.animation.isAnimated ) {
		if (frameIndex != null) {
			drwId += "_" + frameIndex;
		}
		else {
			drwId += "_" + s.animation.frameIndex;
		}
	}

	return imageStore.render[ palId ][ s.col ][ drwId ];
}

function getItemImage(itm,palId,frameIndex) { //aren't these all the same????
	if( frameIndex === undefined ) frameIndex = null; // no default parameter support on iOS

	var drwId = itm.drw;
	// console.log(drwId);

	if (!palId) palId = curPal();

	if ( itm.animation.isAnimated ) {
		if (frameIndex != null) {
			drwId += "_" + frameIndex;
		}
		else {
			drwId += "_" + itm.animation.frameIndex;
		}
	}

	// console.log(imageStore.render[ palId ][ itm.col ]);
	// console.log(imageStore.render[ palId ][ itm.col ][ drwId ]);
	return imageStore.render[ palId ][ itm.col ][ drwId ];
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return "0";
		}
	}
	return "0";	
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();

function onExitDialog() {
	// var breakShit = null;
	// breakShit();
	console.log("EXIT DIALOG");
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
	if (isDialogPreview) {
		isDialogPreview = false;
		if (onDialogPreviewEnd != null)
			onDialogPreviewEnd();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	// console.log("START SPRITE DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr,scriptId) {
	if(dialogStr.length <= 0) {
		console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog();
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	var onScriptEnd = function() {
		if(!dialogBuffer.IsActive()){
			console.log("ON EXIT DIALOG -- startDialog 2");
			onExitDialog();
		}
	};

	if(scriptId === undefined) {
		scriptInterpreter.Interpret( dialogStr, onScriptEnd );		
	}
	else {
		if( !scriptInterpreter.HasScript(scriptId) )
			scriptInterpreter.Compile( scriptId, dialogStr );
		scriptInterpreter.Run( scriptId, onScriptEnd );
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( true );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	onDialogPreviewEnd = onScriptEnd;

	scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
    <audio id='music' autoplay loop preload><source src="pier-music.mp3" type="audio/wav"></audio>
</body>


</html>